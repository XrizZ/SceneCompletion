#include <QCoreApplication>
#include <QtCore>
#include <QImage>

#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <map>
#include <queue>
#include <stdexcept>
#include <cctype>

#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>
#include <boost/thread.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/locks.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/random.hpp>
#include <boost/property_tree/ptree.hpp>

#include <types.hpp>
#include <property.hpp>
#include <generator.hpp>
#include <cmdline.hpp>
#include <imagefiles.h>



// ------------------------------------------------------------
// General usage
//
// a) create filelist for all images below a certrain rootDir:
//
//    generate_filelist -d imagesRootDir -o filelist
//
// b) generate filelist and mapping in case each "object" is
//    by multiple images, e.g one .off file is represented as
//    many view images. The mapping file associates each
//    "view" with a "model"
//
//    generate_filelist -d modelsRootDir -v viewsRootDir -f modelsFilelist -o viewsFilelist modelsViewsMapping
// ------------------------------------------------------------

using namespace imdb;

void progress_lookup_dir(size_t index)
{
    static const int ival = 1000;
    static const char whirl[4] = { '-', '\\', '|', '/' };
    if (index % ival == 0) std::cout << whirl[(index / ival) % 4] << " " << index << '\r' << std::flush;
}

class command_files : public Command
{
    public:

    command_files()
     : Command("files [options]")
     , _co_rootdir      ("rootdir"      , "d", "root directory of files descriptors are compute from [optional, default is '.']")
     , _co_filetype     ("filetype"     , "t", "filetype of files to be listed, [optional, can be 'images' (default) or 'off']")
     , _co_filelist     ("filelist"     , "f", "file that contains existing list of filenames [optional, if not provided all matching files in and below rootdir are listed]")
     , _co_outputfile   ("outputfile"   , "o", "output filelist filename [optional, if not provided, output is console. If in views mode, need to specify two output files")
     , _co_randomsample ("random-sample", "r", "random shuffle and truncate file list to given size [optional]")
     , _co_seed         ("seed"         , "s", "seed value for random-sampling [optional, default is current time]")
     , _co_views_rootdir("viewsrootdir" , "v", "rootdir of views, this activates the mapping mode, i.e. generate a list of views and a mapping that associates each view with a model")
    {
        add(_co_rootdir);
        add(_co_filetype);
        add(_co_filelist);
        add(_co_outputfile);
        add(_co_randomsample);
        add(_co_seed);
        add(_co_views_rootdir);
    }

    bool run(const std::vector<std::string>& args)
    {
        std::string in_rootdir;
        std::string in_filetype;
        std::string in_filelist;
        std::string in_outputfile;
        size_t      in_samples(0);

        warn_for_unknown_option(args);

        // new 31.Oct.2011: rootDir is optional as well, this is helpful
        // if we for example want to modify an existing filelist (e.g.
        // subsampling or outputting to the console).
        in_rootdir = ".";
        if (!_co_rootdir.parse_single<std::string>(args, in_rootdir))
        {
            std::cout << "generate_filelist: no rootdir provided, defaulting to '.'" << std::endl;
        }

        ImageFiles files(in_rootdir);


        // input is an existing filelist
        if (_co_filelist.parse_single<std::string>(args, in_filelist))
        {
            files.load(in_filelist);
        }

        // input is generated by traversing root directory
        else
        {
            // determine filetype first, default is Images
            ImageFiles::FileType fileType = ImageFiles::Images;

            if (_co_filetype.parse_single<std::string>(args, in_filetype))
            {
                if (in_filetype == "off") fileType = ImageFiles::Off;
                if (in_filetype == "obj") fileType = ImageFiles::Obj;
                if (in_filetype == "svg") fileType = ImageFiles::SVG;
            }
            files.lookup_dir(progress_lookup_dir, fileType);
            std::cout << "generate_filelist: listed " << files.size() << " files from " << in_rootdir << std::endl;
        }

        if (_co_randomsample.parse_single<size_t>(args, in_samples))
        {
            size_t in_seed(0);
            if (!_co_seed.parse_single<size_t>(args, in_seed))
            {
                in_seed = QTime::currentTime().msec();
            }

            std::cout << "seed for random sampling: " << in_seed << std::endl;
            files.random_sample(in_samples, in_seed);
        }

        std::string in_views_dir;
        bool views_mode = false;

        if (_co_views_rootdir.parse_single<std::string>(args, in_views_dir))
        {
            QStringList filter;
            filter << "*.png";

            std::vector<std::string> in_outputfiles;
            if (!_co_outputfile.parse_multiple<std::string>(args, in_outputfiles) || in_outputfiles.size() != 2)
            {
                std::cerr << "view list generation: wrong number of arguments, you need to provide two output filenames" << std::endl;
                return false;
            }

            views_mode = true;

            shared_ptr<PropertyWriter> views_writer = PropertyT<std::string>().create_writer(in_outputfiles[0]);
            shared_ptr<PropertyWriter> map_writer = PropertyT<index_t>().create_writer(in_outputfiles[1]);

            for (size_t i = 0; i < files.size(); i++)
            {

                // the trick here is to make sure that the view files in the same subfolder structure
                // that the ith model file lies in are stored at the same indices in the created filelist
                // for the views.
                // I.e. if a model lies in:                   models_root_dir/0/m12/m12.off
                // then we list all views that lie in         views_root_dir/0/m12/*.png
                // Actually the views filelist stores the views listed linearly but the
                // association is stored in the mapping file

                QFileInfo relFilename(files.get_relative_filename(i).c_str());
                QString relPath = relFilename.path();

                QDir dir(QString(in_views_dir.c_str()) + QDir::separator() + relPath);

                QStringList entries = dir.entryList(filter, QDir::Files | QDir::NoDotAndDotDot);

                for (int k = 0; k < entries.size(); k++) {
                    QString filename = relPath + QDir::separator() + entries[k];
                    views_writer->push_back(filename.toStdString());
                    map_writer->push_back(index_t(i));
                }
            }
        }


        if (!views_mode) {
            if (_co_outputfile.parse_single<std::string>(args, in_outputfile))
            {
                // output is a file
                files.store(in_outputfile);
            }
            else
            {
                // output is console
                for (size_t i = 0; i < files.size(); i++) std::cout << files.get_relative_filename(i) << std::endl;
            }
        }

        return true;
    }

    private:

    CmdOption _co_rootdir;
    CmdOption _co_filetype;
    CmdOption _co_filelist;
    CmdOption _co_outputfile;
    CmdOption _co_randomsample;
    CmdOption _co_seed;
    CmdOption _co_views_rootdir;
    //CmdOption _co_viewsoutputfiles;
};



int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    return command_files().run(argv_to_strings(argc - 1, &argv[1])) ? 1 : 0;
}

